参见：
深入分析Java ClassLoader原理
	http://blog.csdn.net/xyang81/article/details/7292380

当程序主动 使用 某个类时
（即是：加载类A时，除了父亲被加载外，其余的引用的类并不是立刻被加载，而是在使用该类时（如：调用该类的静态成员，new出该类的对象）），该类将被加载
加载
	将类的.class文件读入内存（一个byte[]，加载到方法区），产生一个java.lang.Class对象
	类的加载由 classloader 完成，类加载器通常由JVM提供。开发者可以通过继承ClassLoader基类来创建自己的类加载器。
连接
	校验
	准备
		为静态变量分配内存，并设置默认值
	resolve
		将其与 父类/父接口 link在一起
		参见：java.lang.ClassLoader#resolveClass
初始化
	静态变量被赋予正确的值，如：static int age=2，这里的2就是正确的值，而不是int的默认值0
	执行静态代码块

类加载器包括：
Bootstrap classloader
ExtClassLoader
AppClassLoader
用户自定义类加载器（java.lang.ClassLoader的子类）
	有什么用：可以load一个 网络上的class，后，调用该class的方法
	如何实现：复写findClass(String name)
		其最终被java.lang.ClassLoader#loadClass(java.lang.String name, boolean resolve)所调用，该方法内部采用了 父亲委托加载机制
		当获取了byte[]后，可通过java.lang.ClassLoader#defineClass(String name, byte[] b, int off, int len)来产生class对象

加载机制：父亲委托机制:
类的加载首先请求父加载器加载（不是继承关系，而是组合关系），父加载器无能为力时才由自身自行加载。
为什么采用这种方式：
	安全
	避免重复加载
Bootstrap classloader是根加载器，其没有父亲加载器