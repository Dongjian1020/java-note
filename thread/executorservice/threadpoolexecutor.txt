ThreadPoolExecutor(
	int corePoolSize, 
	int maximumPoolSize, 
	long keepAliveTime, 
	TimeUnit unit, 
	BlockingQueue<Runnable> workQueue, 
	RejectedExecutionHandler handler)

参数含义：
corePoolSize : int 
	工作的Worker的数量。
	当工作线程的数量小于corePoolSize时，任务来时，会继续启动新线程，并不重用之前空闲的线程
	当工作线程的数量超过corePoolSize时，任务来时，才开始重用之前的线程处理任务
maximumPoolSize : int 
	线程池中持有的Worker的最大数量
keepAliveTime : long 
	全部worker的数量大于corePoolSize，且有一些worker已经完成了任务，当等待的这段时间里，如果还没有新任务被提交，那么一部分Worker将被回收。
unit : TimeUnit 
	keepAliveTime的单位
workQueue : BlockingQueue 
	缓存任务的队列, 这个队列只缓存提交的Runnable任务。
	如果你提交任务时，线程池队列已满，这时会发生什么
		如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；
		如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。
threadFactory : ThreadFactory 
	产生线程的“工厂”
handler : RejectedExecutionHandler 
	当一个任务被提交的时候，如果所有Worker都在工作并且超过了缓存队列的容量的时候。会交给这个Handler处理。Java 中提供了几种默认的实现，AbortPolicy, CallerRunsPolicy, DiscardOldestPolicy, DiscardPolicy。

例子：
new ThreadPoolExecutor(6, 6, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());

------------------------------asynctask中的THREAD_POOL_EXECUTOR的构建
private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
// We want at least 2 threads and at most 4 threads in the core pool,
// preferring to have 1 less than the CPU count to avoid saturating
// the CPU with background work
private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE_SECONDS = 30;
private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);

    public Thread newThread(Runnable r) {
        return new Thread(r, "AsyncTask #" + mCount.getAndIncrement());
    }
};
private static final BlockingQueue<Runnable> sPoolWorkQueue = new LinkedBlockingQueue<Runnable>(128);

/**
 * An {@link Executor} that can be used to execute tasks in parallel.
 */
public static final Executor THREAD_POOL_EXECUTOR;

static {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}