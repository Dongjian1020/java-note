其对应着 哲学家就餐的问题

acquire
如果当前信号量的个数值>0，那么可以 申请得到
否则，申请不到，申请线程将被阻塞
--
信号量 的初始个数值可以<0

信号量 的初始个数为1时：
可以认为是一个Lock，即是：一个真实的 互斥资源

公平属性：Semaphore(int permits, boolean fair)
即是：线程A和线程B（线程A先申请）都acquire该信号量，但是却都失败而阻塞时，待到线程C release了该信号量后，线程A将获得该信号量（因为其先申请）

哲学家就餐问题
只有N个叉子，却有M个人来共同使用
解决思路：
	两类信号量：可以使用叉子的许可信号量，叉子信号量（一个真实的互斥资源）
	当就餐时，先拿到使用叉子的许可
	后，获取叉子资源

方法：
public void acquire() throws InterruptedException {  }     //获取一个许可，在获得该许可之前，线程将一直阻塞
public void acquire(int permits) throws InterruptedException { }    //和上述方法相比，不同的是：获取permits个信号
public void release() { }          //释放一个许可
public void release(int permits) { }    //释放permits个许可
--
public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false
public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false
public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false

-------------------------例子（哲学家就餐问题）
//import java.util.concurrent.ExecutorService;
//import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

/**
 * 存放线程共享信号量的上下问
 * @author 骆昊
 *
 */
class AppContext {
    public static final int NUM_OF_FORKS = 5;    // 叉子数量(资源)
    public static final int NUM_OF_PHILO = 5;    // 哲学家数量(线程)

    public static Semaphore[] forks;    // 叉子的信号量
    public static Semaphore counter;    // 哲学家的信号量

    static {
        forks = new Semaphore[NUM_OF_FORKS];

        for (int i = 0, len = forks.length; i < len; ++i) {
            forks[i] = new Semaphore(1);    // 每个叉子的信号量为1
        }

        counter = new Semaphore(NUM_OF_PHILO - 1);    // 如果有N个哲学家，最多只允许N-1人同时取叉子
    }

    /**
     * 取得叉子
     * @param index 第几个哲学家
     * @param leftFirst 是否先取得左边的叉子
     * @throws InterruptedException
     */
    public static void putOnFork(int index, boolean leftFirst) throws InterruptedException {
        if(leftFirst) {
            forks[index].acquire();
            forks[(index + 1) % NUM_OF_PHILO].acquire();
        }
        else {
            forks[(index + 1) % NUM_OF_PHILO].acquire();
            forks[index].acquire();
        }
    }

    /**
     * 放回叉子
     * @param index 第几个哲学家
     * @param leftFirst 是否先放回左边的叉子
     * @throws InterruptedException
     */
    public static void putDownFork(int index, boolean leftFirst) throws InterruptedException {
        if(leftFirst) {
            forks[index].release();
            forks[(index + 1) % NUM_OF_PHILO].release();
        }
        else {
            forks[(index + 1) % NUM_OF_PHILO].release();
            forks[index].release();
        }
    }
}

/**
 * 哲学家
 * @author 骆昊
 *
 */
class Philosopher implements Runnable {
    private int index;        // 编号
    private String name;    // 名字

    public Philosopher(int index, String name) {
        this.index = index;
        this.name = name;
    }

    @Override
    public void run() {
        while(true) {
            try {
                AppContext.counter.acquire();
                boolean leftFirst = index % 2 == 0;
                AppContext.putOnFork(index, leftFirst);
                System.out.println(name + "正在吃意大利面（通心粉）...");    // 取到两个叉子就可以进食
                AppContext.putDownFork(index, leftFirst);
                AppContext.counter.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Test04 {

    public static void main(String[] args) {
        String[] names = { "骆昊", "王大锤", "张三丰", "杨过", "李莫愁" };    // 5位哲学家的名字
//        ExecutorService es = Executors.newFixedThreadPool(AppContext.NUM_OF_PHILO);    // 创建固定大小的线程池
//        for(int i = 0, len = names.length; i < len; ++i) {
//            es.execute(new Philosopher(i, names[i]));    // 启动线程
//        }
//        es.shutdown();
        for(int i = 0, len = names.length; i < len; ++i) {
            new Thread(new Philosopher(i, names[i])).start();
        }
    }

}