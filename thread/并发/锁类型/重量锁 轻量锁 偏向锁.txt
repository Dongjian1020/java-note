参见：
Java虚拟机14：Java对象大小、对象内存布局及锁状态变化
	http://www.cnblogs.com/xrq730/p/6928133.html
synchronized、锁、多线程同步的原理是咋样的
	http://www.jianshu.com/p/5dbb07c8d5d5

锁状态有如下：
无锁 - 偏向锁 - 轻量锁 - 重量锁

为什么要有偏向锁/轻量锁：
如：当线程1持有obj的锁，然后线程2请求该锁，后该线程2阻塞（在核心态完成），还没等阻塞操作完成，线程1就释放了锁，那么挂起线程2 本质上是一种性能浪费，
那么只要线程2晚一些请求该锁，或者在请求时发现其他线程持有了该锁后，自身先不阻塞而挂起，而是等待一段时间再请求一下该锁（在有限次中），那么说不定就获得了该锁

偏向锁：
通过设置 对象的mark word中的 线程id为 自身的线程id（通过cas方式）来获得该锁
	如果设置失败，那么说明 当前存在多线程竞争，那么偏向锁会升级为 轻量锁

轻量锁：
通过设置 对象的mark word中的 锁记录指针 指向 某线程的某一栈帧的锁记录（拷贝了 对象的mark word）（通过cas方式），来代表 该线程获得了该锁
	如果设置失败
		有可能该线程的其他栈帧 持有了该锁，那么进行判断
		否则，多线程在竞争该锁，那么轻量锁会升级为重量锁