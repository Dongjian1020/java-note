参见：
Java多线程之wait(),notify(),notifyAll()
	http://blog.csdn.net/oracle_microsoft/article/details/6863662

// wait场景
synchronized(obj) {
　　while(!condition) {
　　		obj.wait();
　　}
　　obj.doSomething();
}

// notify场景
synchronized(obj) {
	obj.doPrepare();
　	condition = true;
	obj.notify();
}

下述场景会有什么问题（当wait变成了这种形式）：
while(!condition) {
	synchronized(obj) {
　　		obj.wait();
　　}
　　obj.doSomething();
}
问题：
wait和notify的逻辑 在不同的线程上执行，当执行完wait的while中的条件判断后（设condition为false），开始执行notify的逻辑，并执行完毕，后继续wait中的剩余逻辑
随后，obj.wait被执行，但是之后，再没有线程执行obj.notify，则wait逻辑永远不会再被唤醒

需要注意的概念是：
　　# 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj){...} 代码段内。
　　# 调用obj.wait()后，线程A就释放了obj的锁，否则线程B无法获得obj锁，也就无法在synchronized(obj){...} 代码段内唤醒A。
　　# 当obj.wait()方法返回后，线程A需要再次获得obj锁，才能继续执行。
　　# 如果A1,A2,A3都在obj.wait()，则B调用obj.notify()只能唤醒A1,A2,A3中的一个（具体哪一个由JVM决定）。
　　# obj.notifyAll()则能全部唤醒A1,A2,A3，但是要继续执行obj.wait()的下一条语句，必须获得obj锁，因此，A1,A2,A3只有一个有机会获得锁继续执行，例如A1，其余的需要等待A1释放obj锁之后才能继续执行。
　　# 当B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1,A2,A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2,A3中的一个才有机会获得锁继续执行。

-----------------------------

obj.wait和thread.sleep的区别
参见：
Java Thread(线程)案例详解sleep和wait的区别
	http://www.cnblogs.com/DreamSea/archive/2012/01/16/SleepAndWaitDifferent.html
sleep和wait的区别.png