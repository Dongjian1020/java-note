可见性
多个线程访问同一个共享变量时，当一个线程修改了该变量后，其他线程再读取该变量时，得到的是 修改后的值（而非自己工作内存中的老值）

volatile
当线程1对 共享变量i 进行修改时，
	会将修改的值先写入到线程1的工作内存，后立即将修改后的值写入主存中，
	会导致线程2的工作内存中缓存变量i的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
		则线程2再次读取变量i的值时，会等待缓存行对应的主存地址被更新之后，然后从对应的主存读取最新的值。

synchronized和Lock
synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
